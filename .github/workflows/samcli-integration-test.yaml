name: samcli-integration-test

on:
  push:
    branches:
      - main
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/e2e-macos.yaml'
      - '.github/workflows/e2e-windows.yaml'
      - '.github/workflows/e2e-linux.yaml'
      - 'contrib/packaging/**'
      - 'deps/**'
      - 'finch.yaml.d/**'
      - 'winres'
      - 'Makefile*'
      - '.golangci.yaml'
      - '!contrib/hello-finch/**'
  pull_request:
    branches:
      - main
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/e2e-macos.yaml'
      - '.github/workflows/e2e-windows.yaml'
      - '.github/workflows/e2e-linux.yaml'
      - 'contrib/packaging/**'
      - 'deps/**'
      - 'finch.yaml.d/**'
      - 'winres'
      - 'Makefile*'
      - '.golangci.yaml'
      - '!contrib/hello-finch/**'
      - '.github/workflows/samcli-integration-test.yaml'
  # schedule:
  #   - cron: '0 9 * * *' # midnight
  workflow_dispatch:    # manual trigger

permissions:
  # This is required for configure-aws-credentials to request an OIDC JWT ID token to access AWS resources later on.
  # More info: https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#adding-permissions-settings
  id-token: write
  contents: read    # This is required for actions/checkout

jobs:
  macos-samcli-test:
    runs-on: macos-latest
    timeout-minutes: 240 # allows 30+ min buffer
    env:
     AWS_DEFAULT_REGION: ${{ secrets.REGION }}
     SAM_CLI_DEV: 1
    steps:

      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          submodules: 'recursive'  # for dependencies (finch-core)

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9' # min. supported by SAMcli

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21 ' # not sure what to put here (recent Go)

      - name: Set up SAM CLI from source
        run: |
          python -m pip install --upgrade pip
          git clone https://github.com/aws/aws-sam-cli.git 
          cd aws-sam-cli
          git checkout $(git describe --tags `git rev-list --tags --max-count=1`)
          git submodule update --init --recursive
          make init
          which samdev
          samdev --version

      - name: Run unit tests
        working-directory: aws-sam-cli  
        run: |

          # Run the unit tests and capture output
          make test | tee unit_test_output.txt

          # # Check if tests passed
          # if ! grep -q "failed=0" unit_test_output.txt; then
          #   echo "Unit tests failed!"
          #   exit 1
          # fi

          # Extract coverage percentage
          COVERAGE=$(grep -o "[0-9]\+%" unit_test_output.txt | head -1 | tr -d '%')

          # Check if coverage is at least 90% (allowing for some variation from the ~94%)
          if [ -z "$COVERAGE" ] || [ "$COVERAGE" -lt 90 ]; then
            echo "Coverage is below expected threshold! Got: $COVERAGE%, Expected: ~94%"
            exit 1
          else
            echo "Unit tests passed with $COVERAGE% coverage (expected ~94%)"
          fi

      - name: Set up Docker and run finch-daemon in Linux container
        run: |
          # Install Docker Desktop
          brew install --cask docker
          
          # Start Docker Desktop
          open -a Docker
          
          # Wait for Docker to start
          echo "Waiting for Docker to start..."
          sleep 30
          
          # Check if Docker is running
          docker info || (echo "Docker failed to start" && exit 1)
          echo "Docker is running successfully"
          
          # Create socket directory
          mkdir -p /tmp/finch-daemon
          chmod 777 /tmp/finch-daemon
          
          # Create a Dockerfile for our Linux container with nerdctl, containerd, and finch-daemon
          cat > Dockerfile.finch << 'EOF'
          FROM ubuntu:22.04
          
          # Install dependencies
          RUN apt-get update && apt-get install -y \
              curl \
              wget \
              git \
              make \
              iptables \
              ca-certificates \
              && rm -rf /var/lib/apt/lists/*
          
          # Install Go 1.22
          RUN wget https://go.dev/dl/go1.22.0.linux-amd64.tar.gz \
              && tar -C /usr/local -xzf go1.22.0.linux-amd64.tar.gz \
              && rm go1.22.0.linux-amd64.tar.gz
          ENV PATH=$PATH:/usr/local/go/bin
          ENV GOPATH=/go
          ENV PATH=$PATH:/go/bin
          
          # Install containerd
          RUN wget https://github.com/containerd/containerd/releases/download/v1.7.2/containerd-1.7.2-linux-amd64.tar.gz \
              && tar -xzf containerd-1.7.2-linux-amd64.tar.gz -C /usr/local \
              && rm containerd-1.7.2-linux-amd64.tar.gz
          
          # Install nerdctl
          RUN wget https://github.com/containerd/nerdctl/releases/download/v1.5.0/nerdctl-1.5.0-linux-amd64.tar.gz \
              && tar -xzf nerdctl-1.5.0-linux-amd64.tar.gz -C /usr/local/bin \
              && rm nerdctl-1.5.0-linux-amd64.tar.gz
          
          # Set up containerd configuration
          RUN mkdir -p /etc/containerd
          RUN containerd config default > /etc/containerd/config.toml
          
          # Create necessary directories
          RUN mkdir -p /tmp/finch-daemon
          RUN mkdir -p /run/containerd
          
          # Set up entrypoint script
          COPY entrypoint.sh /entrypoint.sh
          RUN chmod +x /entrypoint.sh
          
          ENTRYPOINT ["/entrypoint.sh"]
          EOF
          
          # Create entrypoint script
          cat > entrypoint.sh << 'EOF'
          #!/bin/bash
          set -ex
          
          # Start containerd in background
          echo "Starting containerd..."
          /usr/local/bin/containerd &
          
          # Wait for containerd to be ready
          sleep 5
          
          # Check if containerd socket exists
          ls -la /run/containerd/containerd.sock || echo "Containerd socket not found at expected location"
          
          # Clone and build finch-daemon
          echo "Building finch-daemon..."
          git clone https://github.com/runfinch/finch-daemon.git
          cd finch-daemon
          go version
          make
          
          # Start finch-daemon
          echo "Starting finch-daemon..."
          ./bin/finch-daemon --debug --containerd-socket /run/containerd/containerd.sock --listen-socket /tmp/finch-daemon/finch.sock &
          
          # Wait for finch-daemon to be ready
          sleep 5
          
          # Check if finch-daemon socket exists
          ls -la /tmp/finch-daemon/finch.sock || echo "Finch-daemon socket not found"
          
          # Test if daemon is running
          curl --unix-socket /tmp/finch-daemon/finch.sock http://localhost/_ping || echo "Error: finch-daemon is not responding to ping"
          
          # Keep container running
          echo "Setup complete, container is ready"
          tail -f /dev/null
          EOF
          
          # Build the Docker image
          docker build -t finch-daemon-container -f Dockerfile.finch .
          
          # Run the container with privileged mode to allow containerd to work
          docker run -d --name finch-daemon-container \
            --privileged \
            -v /tmp/finch-daemon:/tmp/finch-daemon \
            finch-daemon-container
          
          # Wait for container to be ready
          echo "Waiting for container to be ready..."
          sleep 30
          
          # Show container logs for debugging
          docker logs finch-daemon-container
          
          # Check if finch-daemon is running in the container
          docker exec finch-daemon-container curl --unix-socket /tmp/finch-daemon/finch.sock http://localhost/_ping || (echo "Error: finch-daemon is not running in container" && docker logs finch-daemon-container && exit 1)
          echo "finch-daemon is running successfully in container"
          
          # Export the socket path for later steps
          echo "DOCKER_HOST=unix:///tmp/finch-daemon/finch.sock" >> $GITHUB_ENV

      # - name: Build and initialize Finch
      #   run: |
      #     make
      #     ./_output/bin/finch vm init || ./_output/bin/finch vm start
      #     if ! ./_output/bin/finch vm status | grep -q "Running"; then
      #       echo "Error: Finch VM is not running"
      #       cat ~/.finch/finch.yaml
      #       cat /Users/runner/work/finch/finch/_output/lima/data/finch/ha.stderr.log || echo "No ha.stderr.log file"
      #       exit 1
      #     else
      #       echo "Finch VM is running successfully"
      #     fi

      - name: Run local invoke test
        timeout-minutes: 75
        working-directory: aws-sam-cli
        run: |

          # Run the test, display output
          python -m pytest tests/integration/local/invoke -k 'not Terraform' -v > test_output.txt 2>&1 || true
          cat test_output.txt

          # Create a list of expected failing tests
          cat > expected_failures.txt << 'EOF'
          test_invoke_with_error_during_image_build
          test_invoke_with_timeout_set_0_TimeoutFunction
          test_invoke_with_timeout_set_1_TimeoutFunctionWithParameter
          test_invoke_with_timeout_set_2_TimeoutFunctionWithStringParameter
          test_building_new_rapid_image_removes_old_rapid_images
          test_invoke_returns_expected_results_from_git_function
          test_invoke_returns_expected_results_from_git_function_with_parameters
          EOF

          # Extract actual failing tests
          grep "FAILED" test_output.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_failures.txt

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_failures.txt actual_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Invoke test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Invoke test passed!"
          fi

      - name: Run start-lambda test
        timeout-minutes: 30
        working-directory: aws-sam-cli
        run: |

          # Run the tests
          python -m pytest tests/integration/local/start_lambda -k 'not Terraform' -v > start_lambda_output.txt 2>&1 || true
          cat start_lambda_output.txt

          # Check if any tests failed
          if grep -q "FAILED" start_lambda_output.txt; then
            echo "Some start-lambda tests failed!"
            exit 1
          else
            echo "All start-lambda tests passed!"
          fi


      - name: Run start-api test
        timeout-minutes: 75
        working-directory: aws-sam-cli
        run: |

          # Increase file limit to prevent "too many files open" error
          ulimit -n 4096 || true

          # Run the tests
          python -m pytest tests/integration/local/start_api -k 'not Terraform' -v > start_api_output.txt 2>&1 || true
          cat start_api_output.txt

          # Check if any tests failed
          if grep -q "FAILED" start_api_output.txt; then
            echo "Some start-api tests failed!"
            exit 1
          else
            echo "All start-api tests passed!"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@b47578312673ae6fa5b5096b330d9fbac3d116df # v4.2.1
        with:
          role-to-assume: ${{ secrets.ROLE }}
          role-session-name: samcli-integration-test
          aws-region: us-east-1

      - name: Run sync test
        timeout-minutes: 20
        working-directory: aws-sam-cli
        run: |

          # Run the tests
          python -m pytest tests/integration/sync -k 'image' -v > sync_test.txt 2>&1 || true
          cat sync_test.txt

          # Check if any tests failed
          if grep -q "FAILED" sync_test.txt; then
            echo "Some sync tests failed!"
            exit 1
          else
            echo "All sync tests passed!"
          fi  

      - name: Run package test 
        timeout-minutes: 7
        working-directory: aws-sam-cli
        run: |  

          # Run the tests
          python -m pytest tests/integration/package/test_package_command_image.py > package_test.txt 2>&1 || true
          cat package_test.txt

          # Create a list of expected failing tests
          cat > expected_package_failures.txt << 'EOF'
          test_package_with_deep_nested_template_image
          test_package_template_with_image_repositories_nested_stack
          test_package_with_loadable_image_archive_0_template_image_load_yaml
          EOF

          # Extract actual failing tests
          grep "FAILED" package_test.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_package_failures.txt || true

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_package_failures.txt actual_package_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Package test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Test passed!"
          fi

      - name: Run deploy test
        timeout-minutes: 30
        working-directory: aws-sam-cli
        run: |

          # Run the tests
          python -m pytest tests/integration/deploy -k 'image' > deploy_test.txt 2>&1 || true
          cat deploy_test.txt

          # Check if any tests failed
          if grep -q "PASSED" deploy_test.txt; then
            echo "Some deploy tests passed unexpectedly! This might indicate a change in behavior."
            grep "PASSED" deploy_test.txt
            exit 1
          else
            echo "All deploy tests failed as expected!"
          fi

      - name: Run build test
        working-directory: aws-sam-cli
        run: |  

          # Run the tests
          python -m pytest tests/integration/buildcmd -k '(container or image) and not sar and not terraform' > build_test.txt 2>&1 || true
          cat build_test.txt

          # Create a list of expected failing tests
          cat > expected_build_failures.txt << 'EOF'
          test_with_invalid_dockerfile_definition
          test_with_invalid_dockerfile_location
          test_load_success
          test_building_ruby_3_2_1_use_container
          test_with_makefile_builder_specified_python_runtime_1_use_container
          test_with_native_builder_specified_python_runtime_1_use_container
          test_inline_not_built_1_use_container
          test_json_env_vars_passed_0_use_container
          test_json_env_vars_passed_1_use_container
          test_inline_env_vars_passed_0_use_container
          test_inline_env_vars_passed_1_use_container
          test_custom_build_image_succeeds_0_use_container
          test_custom_build_image_succeeds_1_use_container
          test_building_ruby_in_container_with_specified_architecture_0_ruby3_2
          test_building_java_in_container_with_arm64_architecture_00_java8_al2
          test_building_java_in_container_with_arm64_architecture_03_java8_al2
          test_building_java_in_container_with_arm64_architecture_04_java11
          test_building_java_in_container_with_arm64_architecture_07_java11
          test_building_java_in_container_with_arm64_architecture_08_java17
          test_building_java_in_container_with_arm64_architecture_11_java17
          test_building_java_in_container_with_arm64_architecture_al2023_0_java21
          test_building_java_in_container_with_arm64_architecture_al2023_1_java21
          test_building_java_in_container_with_arm64_architecture_al2023_2_java21
          test_building_java_in_container_with_arm64_architecture_al2023_3_java21
          test_building_java_in_container_00_java8_al2
          EOF

          # Extract actual failing tests
          grep "FAILED" build_test.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_build_failures.txt

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_build_failures.txt actual_build_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Build test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Test passed!"
          fi

  # linux-samcli-test: