name: samcli-test

on:
  push:
    branches:
      - main
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/e2e-macos.yaml'
      - '.github/workflows/e2e-windows.yaml'
      - '.github/workflows/e2e-linux.yaml'
      - 'contrib/packaging/**'
      - 'deps/**'
      - 'finch.yaml.d/**'
      - 'winres'
      - 'Makefile*'
      - '.golangci.yaml'
      - '!contrib/hello-finch/**'
  pull_request:
    branches:
      - main
    paths:
      - '**.go'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/e2e-macos.yaml'
      - '.github/workflows/e2e-windows.yaml'
      - '.github/workflows/e2e-linux.yaml'
      - 'contrib/packaging/**'
      - 'deps/**'
      - 'finch.yaml.d/**'
      - 'winres'
      - 'Makefile*'
      - '.golangci.yaml'
      - '!contrib/hello-finch/**'
      - '.github/workflows/samcli-integration-test.yaml'
      - '.github/workflows/samcli-test.yaml'
  # schedule:
  #   - cron: '0 9 * * *' # midnight
  workflow_dispatch:    # manual trigger

permissions:
  # This is required for configure-aws-credentials to request an OIDC JWT ID token to access AWS resources later on.
  # More info: https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#adding-permissions-settings
  id-token: write
  contents: read    # This is required for actions/checkout
jobs:
  samcli-test:
    runs-on: ubuntu-latest
    timeout-minutes: 250 # allows 30+ min buffer
    env:
      AWS_DEFAULT_REGION: ${{ secrets.REGION }}
      SAM_CLI_DEV: 1
      BY_CANARY: true
    steps:

      # finch-daemon is part of the core
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          submodules: 'recursive'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9' # min. supported by SAMcli

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21 ' # not sure what to put here (recent Go)

      # - name: Make Finch
      #   run: |
      #     make

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@b47578312673ae6fa5b5096b330d9fbac3d116df # v4.2.1
        with:
          role-to-assume: ${{ secrets.ROLE }}
          role-session-name: samcli-integration-test
          aws-region: ${{ secrets.REGION }}

      - name: Set up SAM CLI from source
        run: |
          python -m pip install --upgrade pip
          git clone https://github.com/aws/aws-sam-cli.git
          cd aws-sam-cli
          git checkout $(git describe --tags `git rev-list --tags --max-count=1`)
          git submodule update --init --recursive
          make init
          which samdev
          samdev --version

      - name: Run unit tests
        working-directory: aws-sam-cli  
        run: |

          # Run the unit tests and capture output
          make test | tee unit_test_output.txt

          # # Check if tests passed
          # if ! grep -q "failed=0" unit_test_output.txt; then
          #   echo "Unit tests failed!"
          #   exit 1
          # fi

          # Extract coverage percentage
          COVERAGE=$(grep -o "[0-9]\+%" unit_test_output.txt | head -1 | tr -d '%')

          # Check if coverage is at least 90% (allowing for some variation from the ~94%)
          if [ -z "$COVERAGE" ] || [ "$COVERAGE" -lt 90 ]; then
            echo "Coverage is below expected threshold! Got: $COVERAGE%, Expected: ~94%"
            exit 1
          else
            echo "Unit tests passed with $COVERAGE% coverage (expected ~94%)"
          fi

      - name: Setup finch-daemon environment
        run: |
          # Set versions
          RUNC_VERSION=1.3.0
          NERDCTL_VERSION=2.1.3
          BUILDKIT_VERSION=0.23.2
          CNI_VERSION=1.6.2

          # Install dependencies
          sudo apt update && sudo apt install -y make gcc linux-libc-dev libseccomp-dev pkg-config git

          # Download and install containerd
          # Note: CONTAINERD_VERSION is not defined in the original script, so we need to set it
          CONTAINERD_VERSION=1.7.0
          curl -sSL --output /tmp/containerd.tgz https://github.com/containerd/containerd/releases/download/v${CONTAINERD_VERSION}/containerd-${CONTAINERD_VERSION}-linux-amd64.tar.gz
          sudo tar zxvf /tmp/containerd.tgz -C /usr/local/
          rm -f /tmp/containerd.tgz

          # Download and install runc
          curl -sSL --output /tmp/runc https://github.com/opencontainers/runc/releases/download/v${RUNC_VERSION}/runc.amd64
          sudo cp /tmp/runc /usr/local/bin/
          sudo chmod +x /usr/local/bin/runc
          rm -f /tmp/runc

          # Download and install nerdctl
          curl -sSL --output /tmp/nerdctl.tgz https://github.com/containerd/nerdctl/releases/download/v${NERDCTL_VERSION}/nerdctl-${NERDCTL_VERSION}-linux-amd64.tar.gz
          sudo tar zxvf /tmp/nerdctl.tgz -C /usr/local/bin/
          rm -f /tmp/nerdctl.tgz

          # Download and install buildkit
          curl -sSL --output /tmp/buildkit.tgz https://github.com/moby/buildkit/releases/download/v${BUILDKIT_VERSION}/buildkit-v${BUILDKIT_VERSION}.linux-amd64.tar.gz
          sudo tar zxvf /tmp/buildkit.tgz -C /usr/local/bin/
          sudo mv /usr/local/bin/bin/* /usr/local/bin/
          rm /tmp/buildkit.tgz

          # Download and install cni-plugins
          sudo rm -rf /opt/cni/bin/*
          wget https://github.com/containernetworking/plugins/releases/download/v${CNI_VERSION}/cni-plugins-linux-amd64-v${CNI_VERSION}.tgz
          sudo mkdir -p /opt/cni/bin
          sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v${CNI_VERSION}.tgz

          export PATH=$PATH:/usr/local/bin

          sudo containerd &
          sudo buildkitd &

          sleep 2

      - name: Setup finch-daemon
        run: |
          # Navigate to finch-daemon directory and build it
          cd deps/finch-core/src/finch-daemon
          make

          # Create data directory
          sudo mkdir -p /var/lib/finch-daemon
          sudo chmod 777 /var/lib/finch-daemon

          # Start finch-daemon using the binary we just built
          echo "Starting finch-daemon from bin/finch-daemon"
          sudo ./bin/finch-daemon --debug &
          sleep 5

          # Check if finch-daemon socket exists
          ls -la /run/finch.sock /run/finch-credential.sock || echo "Finch-daemon socket not found"

          # Fix socket permissions if needed
          sudo chmod 666 /run/finch.sock /run/finch-credential.sock 2>/dev/null || true
          sudo chmod 666 /run/containerd/containerd.sock 2>/dev/null || true

          # Verify the daemon is running
          curl --unix-socket /run/finch.sock http://localhost/v1.35/version || (echo "Error: finch-daemon is not responding" && exit 1)
          curl --unix-socket /run/finch.sock http://localhost/_ping || (echo "Error: finch-daemon ping failed" && exit 1)
          echo "finch-daemon is running successfully"

      - name: Configure container registry access
        run: |
          # Create containerd configuration directory
          sudo mkdir -p /etc/containerd

          # Create a basic containerd config
          cat > /tmp/config.toml << EOF
          version = 2

          [plugins."io.containerd.grpc.v1.cri"]
            sandbox_image = "registry.k8s.io/pause:3.6"
            [plugins."io.containerd.grpc.v1.cri".registry]
              [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
                [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
                  endpoint = ["https://registry-1.docker.io"]
                [plugins."io.containerd.grpc.v1.cri".registry.mirrors."public.ecr.aws"]
                  endpoint = ["https://public.ecr.aws"]

          [plugins."io.containerd.internal.v1.opt"]
            path = "/opt/containerd"
          EOF

          sudo mv /tmp/config.toml /etc/containerd/config.toml

          # Restart containerd with the new config
          sudo pkill containerd || true
          sleep 2
          sudo containerd --config /etc/containerd/config.toml &
          sleep 5

          # Restart finch-daemon to reconnect to containerd
          cd deps/finch-core/src/finch-daemon
          sudo pkill finch-daemon || true
          sleep 2
          sudo ./bin/finch-daemon --debug &
          sleep 5

          # Fix socket permissions if needed
          sudo chmod 666 /run/finch.sock /run/finch-credential.sock 2>/dev/null || true
          sudo chmod 666 /run/containerd/containerd.sock 2>/dev/null || true

          # Create Docker config directory for credentials
          mkdir -p ~/.docker

          # Create Finch config directory
          mkdir -p ~/.finch

          # Create a basic Docker config with empty auth (allows anonymous pulls)
          echo '{"auths":{"docker.io":{},"public.ecr.aws":{}}}' > ~/.docker/config.json

          # Copy the same config to Finch directory
          cp ~/.docker/config.json ~/.finch/config.json

          # Set DOCKER_CONFIG environment variable
          echo "DOCKER_CONFIG=$HOME/.finch" >> $GITHUB_ENV

          # Test pulling a small image to verify registry access
          curl --unix-socket /run/finch.sock -X POST "http://localhost/v1.35/images/create?fromImage=hello-world:latest"

          # Verify the image was pulled
          curl --unix-socket /run/finch.sock "http://localhost/v1.35/images/json" | grep hello-world

          # Configure AWS ECR credentials
          aws ecr-public get-login-password --region us-east-1 | \
          curl --unix-socket /run/finch.sock -X POST "http://localhost/v1.35/auth" \
          -H "Content-Type: application/json" \
          -d '{"username":"AWS","password":"'$(aws ecr-public get-login-password --region us-east-1)'","serveraddress":"public.ecr.aws"}'

          # Pre-pull Lambda base images that will be needed
          curl --unix-socket /run/finch.sock -X POST "http://localhost/v1.35/images/create?fromImage=public.ecr.aws/lambda/python:3.6"
          curl --unix-socket /run/finch.sock -X POST "http://localhost/v1.35/images/create?fromImage=public.ecr.aws/lambda/python:3.9"

          echo "Container registry configuration complete"

      - name: Run local invoke test
        timeout-minutes: 75
        working-directory: aws-sam-cli
        run: |
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the test, display output
          python -m pytest tests/integration/local/invoke -k 'not Terraform' -v > test_output.txt 2>&1 || true
          cat test_output.txt

          # Create a list of expected failing tests
          cat > expected_failures.txt << 'EOF'
          test_invoke_with_error_during_image_build
          test_invoke_with_timeout_set_0_TimeoutFunction
          test_invoke_with_timeout_set_1_TimeoutFunctionWithParameter
          test_invoke_with_timeout_set_2_TimeoutFunctionWithStringParameter
          test_building_new_rapid_image_removes_old_rapid_images
          test_invoke_returns_expected_results_from_git_function
          test_invoke_returns_expected_results_from_git_function_with_parameters
          EOF

          # Extract actual failing tests
          grep "FAILED" test_output.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_failures.txt

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_failures.txt actual_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Invoke test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Invoke test passed!"
          fi

      - name: Run start-lambda test
        timeout-minutes: 30
        working-directory: aws-sam-cli
        run: |
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the tests
          python -m pytest tests/integration/local/start_lambda -k 'not Terraform' -v > start_lambda_output.txt 2>&1 || true
          cat start_lambda_output.txt

          # Check if any tests failed
          if grep -q "FAILED" start_lambda_output.txt; then
            echo "Some start-lambda tests failed!"
            exit 1
          else
            echo "All start-lambda tests passed!"
          fi

      - name: Run start-api test
        timeout-minutes: 75
        working-directory: aws-sam-cli
        run: |
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Increase file limit to prevent "too many files open" error
          ulimit -n 4096 || true

          # Run the tests
          python -m pytest tests/integration/local/start_api -k 'not Terraform' -v > start_api_output.txt 2>&1 || true
          cat start_api_output.txt

          # Check if any tests failed
          if grep -q "FAILED" start_api_output.txt; then
            echo "Some start-api tests failed!"
            exit 1
          else
            echo "All start-api tests passed!"
          fi

      - name: Run sync test
        timeout-minutes: 20
        working-directory: aws-sam-cli
        run: |
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the tests
          python -m pytest tests/integration/sync -k 'image' -v > sync_test.txt 2>&1 || true
          cat sync_test.txt

          # Check if any tests failed
          if grep -q "FAILED" sync_test.txt; then
            echo "Some sync tests failed!"
            exit 1
          else
            echo "All sync tests passed!"
          fi  

      - name: Run package test 
        timeout-minutes: 7
        working-directory: aws-sam-cli
        run: |  
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the tests
          python -m pytest tests/integration/package/test_package_command_image.py > package_test.txt 2>&1 || true
          cat package_test.txt

          # Create a list of expected failing tests
          cat > expected_package_failures.txt << 'EOF'
          test_package_with_deep_nested_template_image
          test_package_template_with_image_repositories_nested_stack
          test_package_with_loadable_image_archive_0_template_image_load_yaml
          EOF

          # Extract actual failing tests
          grep "FAILED" package_test.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_package_failures.txt || true

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_package_failures.txt actual_package_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Package test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Test passed!"
          fi

      - name: Run deploy test
        timeout-minutes: 30
        working-directory: aws-sam-cli
        run: |
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the tests
          python -m pytest tests/integration/deploy -k 'image' > deploy_test.txt 2>&1 || true
          cat deploy_test.txt

          # Check if any tests failed
          if grep -q "PASSED" deploy_test.txt; then
            echo "Some deploy tests passed unexpectedly! This might indicate a change in behavior."
            grep "PASSED" deploy_test.txt
            exit 1
          else
            echo "All deploy tests failed as expected!"
          fi

      - name: Run build test
        working-directory: aws-sam-cli
        run: |  
          export DOCKER_CONFIG= ${{ env.DOCKER_CONFIG }}
          export DOCKER_HOST=unix:///run/finch.sock

          # Run the tests
          python -m pytest tests/integration/buildcmd -k '(container or image) and not sar and not terraform' > build_test.txt 2>&1 || true
          cat build_test.txt

          # Create a list of expected failing tests
          cat > expected_build_failures.txt << 'EOF'
          test_with_invalid_dockerfile_definition
          test_with_invalid_dockerfile_location
          test_load_success
          test_building_ruby_3_2_1_use_container
          test_with_makefile_builder_specified_python_runtime_1_use_container
          test_with_native_builder_specified_python_runtime_1_use_container
          test_inline_not_built_1_use_container
          test_json_env_vars_passed_0_use_container
          test_json_env_vars_passed_1_use_container
          test_inline_env_vars_passed_0_use_container
          test_inline_env_vars_passed_1_use_container
          test_custom_build_image_succeeds_0_use_container
          test_custom_build_image_succeeds_1_use_container
          test_building_ruby_in_container_with_specified_architecture_0_ruby3_2
          test_building_java_in_container_with_arm64_architecture_00_java8_al2
          test_building_java_in_container_with_arm64_architecture_03_java8_al2
          test_building_java_in_container_with_arm64_architecture_04_java11
          test_building_java_in_container_with_arm64_architecture_07_java11
          test_building_java_in_container_with_arm64_architecture_08_java17
          test_building_java_in_container_with_arm64_architecture_11_java17
          test_building_java_in_container_with_arm64_architecture_al2023_0_java21
          test_building_java_in_container_with_arm64_architecture_al2023_1_java21
          test_building_java_in_container_with_arm64_architecture_al2023_2_java21
          test_building_java_in_container_with_arm64_architecture_al2023_3_java21
          test_building_java_in_container_00_java8_al2
          EOF

          # Extract actual failing tests
          grep "FAILED" build_test.txt | sed 's/.*::\(test_[a-zA-Z0-9_]*\).*/\1/' > actual_build_failures.txt

          # Find unexpected failures (failures not in the expected list)
          UNEXPECTED_FAILURES=$(grep -v -f expected_build_failures.txt actual_build_failures.txt || true)

          # Check if there are any unexpected failures
          if [ -n "$UNEXPECTED_FAILURES" ]; then
            echo "Unexpected test failures found:"
            echo "$UNEXPECTED_FAILURES"
            echo "Build test failed due to unexpected test failures"
            exit 1
          else
            echo "All test failures were expected. Test passed!"
          fi