// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//go:build darwin || windows

package vm

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/onsi/ginkgo/v2"
	"github.com/onsi/gomega"
	"github.com/runfinch/common-tests/command"
	"github.com/runfinch/common-tests/ffs"
	"github.com/runfinch/common-tests/fnet"
	"github.com/runfinch/common-tests/option"
)

// RegistryInfo contains registry connection details
type RegistryInfo struct {
	URL      string
	Username string
	Password string
}

// setupTestRegistry creates an authenticated local registry and returns connection info
func setupTestRegistry(o *option.Option) *RegistryInfo {
	filename := "htpasswd"
	registryImage := "public.ecr.aws/docker/library/registry:2"
	registryContainer := "auth-registry"
	// The htpasswd is generated by
	// `finch run --entrypoint htpasswd public.ecr.aws/docker/library/httpd:2 -Bbn testUser testPassword`.
	// We don't want to generate it on the fly because:
	// 1. Pulling the httpd image can take a long time, sometimes even more 10 seconds.
	// 2. It's unlikely that we will have to update this in the future.
	// 3. It's not the thing we want to validate by the functional tests. We only want the output produced by it.
	//nolint:gosec // This password is only used for testing purpose.
	htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
	htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
	ginkgo.DeferCleanup(os.RemoveAll, htpasswdDir)
	port := fnet.GetFreePort()
	containerID := command.StdoutStr(o, "run",
		"-dp", fmt.Sprintf("%d:5000", port),
		"--name", registryContainer,
		"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
		"-e", "REGISTRY_AUTH=htpasswd",
		"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
		"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
		registryImage)
	ginkgo.DeferCleanup(command.Run, o, "rmi", "-f", registryImage)
	ginkgo.DeferCleanup(command.Run, o, "rm", "-f", registryContainer)
	for command.StdoutStr(o, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
		time.Sleep(1 * time.Second)
	}
	time.Sleep(10 * time.Second)
	registry := fmt.Sprintf(`localhost:%d`, port)

	return &RegistryInfo{
		URL:      registry,
		Username: "testUser",
		Password: "testPassword",
	}
}

// setupCredentialEnvironment creates a fresh credential store environment for testing
func setupCredentialEnvironment() func() {
	if runtime.GOOS == "darwin" && os.Getenv("CI") == "true" {
		// Create fresh keychain for macOS CI
		homeDir, err := os.UserHomeDir()
		gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
		keychainsDir := filepath.Join(homeDir, "Library", "Keychains")
		loginKeychainPath := filepath.Join(keychainsDir, "login.keychain-db")
		keychainPassword := "test-password"

		// Remove existing keychain if present
		exec.Command("security", "delete-keychain", loginKeychainPath).Run()

		// Create Keychains directory
		err = os.MkdirAll(keychainsDir, 0755)
		gomega.Expect(err).ShouldNot(gomega.HaveOccurred())

		// Create and setup keychain
		exec.Command("security", "create-keychain", "-p", keychainPassword, loginKeychainPath).Run()
		exec.Command("security", "unlock-keychain", "-p", keychainPassword, loginKeychainPath).Run()
		exec.Command("security", "list-keychains", "-s", loginKeychainPath, "/Library/Keychains/System.keychain").Run()
		exec.Command("security", "default-keychain", "-s", loginKeychainPath).Run()

		// Return cleanup function
		return func() {
			exec.Command("security", "delete-keychain", loginKeychainPath).Run()
		}
	}
	// Windows credential store doesn't need special setup
	return func() {}
}

// setupFreshFinchConfig creates/replaces ~/.finch/config.json with credential helper configured
func setupFreshFinchConfig() {
	var finchRootDir string
	var err error
	if runtime.GOOS == "windows" {
		finchRootDir = os.Getenv("LOCALAPPDATA")
	} else {
		finchRootDir, err = os.UserHomeDir()
		gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
	}

	finchDir := filepath.Join(finchRootDir, ".finch")
	err = os.MkdirAll(finchDir, 0755)
	gomega.Expect(err).ShouldNot(gomega.HaveOccurred())

	configPath := filepath.Join(finchDir, "config.json")
	var credStore string
	if runtime.GOOS == "windows" {
		credStore = "wincred"
	} else {
		credStore = "osxkeychain"
	}

	configContent := fmt.Sprintf(`{"credsStore": "%s"}`, credStore)
	err = os.WriteFile(configPath, []byte(configContent), 0644)
	gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
}

// testNativeCredHelper tests native credential helper functionality.
var testNativeCredHelper = func(o *option.Option, installed bool) {
	ginkgo.Describe("Native Credential Helper", func() {

		// ginkgo.It("should be able to access native credential store in CI", func() {
		// 	// Setup fresh credential environment and config
		// 	cleanupCreds := setupCredentialEnvironment()
		// 	defer cleanupCreds()
		// 	setupFreshFinchConfig()

		// 	var nativeCredHelper string
		// 	if runtime.GOOS == "windows" {
		// 		nativeCredHelper = "docker-credential-wincred.exe"
		// 	} else {
		// 		nativeCredHelper = "docker-credential-osxkeychain"
		// 	}

		// 	fmt.Printf("ğŸ§ª TESTING NATIVE CREDENTIAL HELPER ACCESS IN CI\n")
		// 	fmt.Printf("ğŸ§ª Using credential helper: %s\n", nativeCredHelper)

		// 	// Print current user and environment info
		// 	currentUser := os.Getenv("USER")
		// 	if currentUser == "" {
		// 		currentUser = os.Getenv("USERNAME") // Windows fallback
		// 	}
		// 	homeDir := os.Getenv("HOME")
		// 	if homeDir == "" {
		// 		homeDir = os.Getenv("USERPROFILE") // Windows fallback
		// 	}
		// 	fmt.Printf("ğŸ§ª Running as user: %s\n", currentUser)
		// 	fmt.Printf("ğŸ§ª Home directory: %s\n", homeDir)
		// 	fmt.Printf("ğŸ§ª CI environment: %s\n", os.Getenv("CI"))
		// 	fmt.Printf("ğŸ§ª GitHub Actions: %s\n", os.Getenv("GITHUB_ACTIONS"))

		// 	// Test 1: Store a test credential
		// 	testServer := "test-ci-server.example.com"
		// 	testCred := `{"ServerURL":"` + testServer + `","Username":"testuser","Secret":"testpass"}`
		// 	fmt.Printf("ğŸ§ª Step 1: Storing test credential for %s\n", testServer)
		// 	storeCmd := exec.Command(nativeCredHelper, "store")
		// 	storeCmd.Stdin = strings.NewReader(testCred)
		// 	storeOutput, storeErr := storeCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ§ª Store result: error=%v, output=%s\n", storeErr, string(storeOutput))

		// 	// Test 2: List credentials
		// 	fmt.Printf("ğŸ§ª Step 2: Listing stored credentials\n")
		// 	listCmd := exec.Command(nativeCredHelper, "list")
		// 	listOutput, listErr := listCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ§ª List result: error=%v, output=%s\n", listErr, string(listOutput))

		// 	// Test 3: Get the stored credential
		// 	fmt.Printf("ğŸ§ª Step 3: Retrieving stored credential\n")
		// 	getCmd := exec.Command(nativeCredHelper, "get")
		// 	getCmd.Stdin = strings.NewReader(testServer)
		// 	getOutput, getErr := getCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ§ª Get result: error=%v, output=%s\n", getErr, string(getOutput))

		// 	// Test 4: Erase the test credential
		// 	fmt.Printf("ğŸ§ª Step 4: Erasing test credential\n")
		// 	eraseCmd := exec.Command(nativeCredHelper, "erase")
		// 	eraseCmd.Stdin = strings.NewReader(testServer)
		// 	eraseOutput, eraseErr := eraseCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ§ª Erase result: error=%v, output=%s\n", eraseErr, string(eraseOutput))

		// 	// Test 5: Verify credential was erased
		// 	fmt.Printf("ğŸ§ª Step 5: Verifying credential was erased\n")
		// 	verifyCmd := exec.Command(nativeCredHelper, "get")
		// 	verifyCmd.Stdin = strings.NewReader(testServer)
		// 	verifyOutput, verifyErr := verifyCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ§ª Verify result: error=%v, output=%s\n", verifyErr, string(verifyOutput))

		// 	if storeErr != nil {
		// 		fmt.Printf("âŒ NATIVE CREDENTIAL HELPER CANNOT STORE CREDENTIALS IN CI\n")
		// 		fmt.Printf("âŒ This explains why login fails - keychain/credential store access is blocked\n")
		// 		fmt.Printf("âŒ Store error: %v\n", storeErr)
		// 	} else {
		// 		fmt.Printf("âœ… NATIVE CREDENTIAL HELPER WORKS IN CI\n")
		// 		gomega.Expect(storeErr).NotTo(gomega.HaveOccurred(), "Should be able to store credentials")
		// 	}
		// })

		ginkgo.It("should create and access credential socket during operations", func() {
			// Setup fresh credential environment and config
			cleanupCreds := setupCredentialEnvironment()
			defer cleanupCreds()
			setupFreshFinchConfig()

			resetVM(o)
			resetDisks(o, installed)
			command.New(o, virtualMachineRootCmd, "init").WithTimeoutInSeconds(160).Run()

			limaOpt, err := limaCtlOpt(installed)
			gomega.Expect(err).NotTo(gomega.HaveOccurred())

			fmt.Printf("ğŸ”Œ TESTING CREDENTIAL SOCKET CREATION AND ACCESS\n")

			// Step 1: Check socket directory on HOST before operation
			fmt.Printf("ğŸ”Œ Step 1: Checking socket directory on host before credential operation\n")

			// Determine finchRootPath based on installation type
			var finchRootPath string
			if installed {
				if runtime.GOOS == "windows" {
					finchRootPath = "C:\\Program Files\\Finch"
				} else {
					finchRootPath = "/Applications/Finch"
				}
			} else {
				// Development build
				wd, _ := os.Getwd()
				finchRootPath = filepath.Join(wd, "..", "..", "_output")
			}

			socketPath := filepath.Join(finchRootPath, "lima", "data", "finch", "sock", "creds.sock")
			socketDir := filepath.Dir(socketPath)
			fmt.Printf("ğŸ”Œ Expected socket path: %s\n", socketPath)

			// Check host socket directory structure
			if _, err := os.Stat(finchRootPath); os.IsNotExist(err) {
				fmt.Printf("ğŸ”Œ Finch root directory does not exist: %s\n", finchRootPath)
			} else {
				fmt.Printf("ğŸ”Œ Finch root directory exists: %s\n", finchRootPath)

				limaDataDir := filepath.Join(finchRootPath, "lima", "data")
				if _, err := os.Stat(limaDataDir); os.IsNotExist(err) {
					fmt.Printf("ğŸ”Œ Lima data directory does not exist: %s\n", limaDataDir)
				} else {
					fmt.Printf("ğŸ”Œ Lima data directory exists: %s\n", limaDataDir)

					if _, err := os.Stat(socketDir); os.IsNotExist(err) {
						fmt.Printf("ğŸ”Œ Socket directory does not exist: %s\n", socketDir)
					} else {
						fmt.Printf("ğŸ”Œ Socket directory exists: %s\n", socketDir)
						if _, err := os.Stat(socketPath); err == nil {
							fmt.Printf("ğŸ”Œ Socket already exists before operation: %s\n", socketPath)
						} else {
							fmt.Printf("ğŸ”Œ Socket does not exist before operation: %s\n", socketPath)
						}
					}
				}
			}

			// Step 2: Start background monitoring on BOTH host and VM
			fmt.Printf("ğŸ”Œ Step 2: Starting background socket monitoring on host and VM\n")
			
			// Host monitor
			socketFoundOnHost := false
			hostMonitorDone := make(chan bool, 1)
			go func() {
				defer func() {
					select {
					case hostMonitorDone <- true:
					default:
					}
				}()
				for {
					select {
					case <-hostMonitorDone:
						return
					default:
						if _, err := os.Stat(socketPath); err == nil {
							fmt.Printf("ğŸ”Œ SOCKET_FOUND on host: %s\n", socketPath)
							socketFoundOnHost = true
							return
						}
						time.Sleep(100 * time.Millisecond)
					}
				}
			}()
			
			// VM monitor - check platform-specific socket paths
			socketFoundInVM := false
			vmMonitorDone := make(chan bool, 1)
			go func() {
				defer func() {
					select {
					case vmMonitorDone <- true:
					default:
					}
				}()
				for {
					select {
					case <-vmMonitorDone:
						return
					default:
						// Check VM socket paths
						var vmSocketCheck *command.Command
						if runtime.GOOS == "windows" {
							// Check Windows mount paths
							vmSocketCheck = command.New(limaOpt, "shell", "finch", "sh", "-c", "for path in '/mnt/c/Program Files/Finch' '/c/actions-runner/_work/finch/finch/_output'; do if [ -S \"$path/lima/data/finch/sock/creds.sock\" ]; then echo \"FOUND:$path/lima/data/finch/sock/creds.sock\"; exit 0; fi; done; exit 1")
						} else {
							// Check macOS port-forwarded path
							vmSocketCheck = command.New(limaOpt, "shell", "finch", "sh", "-c", "if [ -S '/run/finch-user-sockets/creds.sock' ]; then echo 'FOUND:/run/finch-user-sockets/creds.sock'; exit 0; else exit 1; fi")
						}
						
						result := vmSocketCheck.WithoutCheckingExitCode().Run()
						if result.ExitCode() == 0 {
							fmt.Printf("ğŸ”Œ SOCKET_FOUND in VM: %s\n", strings.TrimSpace(string(result.Out.Contents())))
							socketFoundInVM = true
							return
						}
						time.Sleep(100 * time.Millisecond)
					}
				}
			}()

			// Step 3: Trigger credential operation that should create socket
			fmt.Printf("ğŸ”Œ Step 3: Triggering credential operation (pull hello-world)\n")
			pullResult := command.New(o, "pull", "hello-world").WithTimeoutInSeconds(30).WithoutCheckingExitCode().Run()
			fmt.Printf("ğŸ”Œ Pull result: exit=%d, stderr=%s\n", pullResult.ExitCode(), string(pullResult.Err.Contents()))

			// Give monitor a moment to detect socket
			time.Sleep(500 * time.Millisecond)

			// Step 4: Check socket detection results
			fmt.Printf("ğŸ”Œ Step 4: Checking socket detection results\n")
			
			// Report host socket status
			if socketFoundOnHost {
				fmt.Printf("ğŸ”Œ âœ… Socket was created on host during operation (now cleaned up)\n")
			} else {
				// Double-check if socket still exists (unlikely since operation completed)
				if _, err := os.Stat(socketPath); err == nil {
					fmt.Printf("ğŸ”Œ âœ… Socket still exists on host after operation: %s\n", socketPath)
				} else {
					fmt.Printf("ğŸ”Œ âŒ Socket was NOT detected on host during operation\n")
				}
			}
			
			// Report VM socket status
			if socketFoundInVM {
				fmt.Printf("ğŸ”Œ âœ… Socket was accessible in VM during operation\n")
			} else {
				fmt.Printf("ğŸ”Œ âŒ Socket was NOT accessible in VM during operation\n")
				
				// Double-check VM socket paths now
				fmt.Printf("ğŸ”Œ Double-checking VM socket paths after operation...\n")
				if runtime.GOOS == "windows" {
					socketTestResult := command.New(limaOpt, "shell", "finch", "sh", "-c", "echo \"Checking Windows socket paths:\"; for path in '/mnt/c/Program Files/Finch' '/c/actions-runner/_work/finch/finch/_output'; do SOCKET_PATH=\"$path/lima/data/finch/sock/creds.sock\"; echo \"Checking: $SOCKET_PATH\"; if [ -S \"$SOCKET_PATH\" ]; then echo \"Socket found: $SOCKET_PATH\"; else echo \"Socket not found: $SOCKET_PATH\"; fi; done").WithTimeoutInSeconds(5).WithoutCheckingExitCode().Run()
					fmt.Printf("ğŸ”Œ Windows VM Check:\n%s\n", string(socketTestResult.Out.Contents()))
				} else {
					socketTestResult := command.New(limaOpt, "shell", "finch", "sh", "-c", "echo \"Checking macOS socket path:\"; SOCKET_PATH='/run/finch-user-sockets/creds.sock'; echo \"Checking: $SOCKET_PATH\"; if [ -S \"$SOCKET_PATH\" ]; then echo \"Socket found: $SOCKET_PATH\"; else echo \"Socket not found: $SOCKET_PATH\"; fi").WithTimeoutInSeconds(5).WithoutCheckingExitCode().Run()
					fmt.Printf("ğŸ”Œ macOS VM Check:\n%s\n", string(socketTestResult.Out.Contents()))
				}
			}

		})

		// ginkgo.It("should work with registry push/pull workflow", func() {
		// 	// Clean config and setup fresh environment
		// 	cleanFinchConfig()
		// 	resetVM(o)
		// 	resetDisks(o, installed)
		// 	command.New(o, virtualMachineRootCmd, "init").WithTimeoutInSeconds(160).Run()

		// 	// Setup test registry - EXACTLY like testFinchConfigFile
		// 	filename := "htpasswd"
		// 	registryImage := "public.ecr.aws/docker/library/registry:2"
		// 	registryContainer := "auth-registry"
		// 	//nolint:gosec // This password is only used for testing purpose.
		// 	htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
		// 	htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
		// 	ginkgo.DeferCleanup(os.RemoveAll, htpasswdDir)
		// 	port := fnet.GetFreePort()
		// 	containerID := command.StdoutStr(o, "run",
		// 		"-dp", fmt.Sprintf("%d:5000", port),
		// 		"--name", registryContainer,
		// 		"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
		// 		"-e", "REGISTRY_AUTH=htpasswd",
		// 		"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
		// 		"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
		// 		registryImage)
		// 	ginkgo.DeferCleanup(command.Run, o, "rmi", "-f", registryImage)
		// 	ginkgo.DeferCleanup(command.Run, o, "rm", "-f", registryContainer)
		// 	for command.StdoutStr(o, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
		// 		time.Sleep(1 * time.Second)
		// 	}
		// 	fmt.Printf("ğŸ”§ Registry container is running, waiting for HTTP service...\n")
		// 	time.Sleep(10 * time.Second)
		// 	registry := fmt.Sprintf(`localhost:%d`, port)

		// 	// Test registry readiness with curl and debug output
		// 	limaOpt, err := limaCtlOpt(installed)
		// 	gomega.Expect(err).NotTo(gomega.HaveOccurred())

		// 	fmt.Printf("ğŸ” Testing registry HTTP endpoint: %s/v2/\n", registry)
		// 	for i := 0; i < 10; i++ {
		// 		curlResult := command.New(limaOpt, "shell", "finch", "curl", "-v", "-s", "-w", "\nHTTP_CODE:%{http_code}\n", fmt.Sprintf("http://%s/v2/", registry)).WithoutCheckingExitCode().Run()
		// 		fmt.Printf("ğŸ” Curl attempt %d: exit=%d\n", i+1, curlResult.ExitCode())
		// 		fmt.Printf("ğŸ” Curl stdout:\n%s\n", string(curlResult.Out.Contents()))
		// 		fmt.Printf("ğŸ” Curl stderr:\n%s\n", string(curlResult.Err.Contents()))

		// 		if curlResult.ExitCode() == 0 {
		// 			output := string(curlResult.Out.Contents())
		// 			if strings.Contains(output, "HTTP_CODE:401") {
		// 				fmt.Printf("âœ… Registry HTTP service ready (got 401 auth required)\n")
		// 				break
		// 			}
		// 		}
		// 		time.Sleep(2 * time.Second)
		// 	}
		// 	fmt.Printf("ğŸ”§ Registry setup complete: %s (user: testUser)\n", registry)

		// 	// Verify credential helper is available in VM
		// 	helperCheck := command.New(limaOpt, "shell", "finch", "command", "-v", "docker-credential-finchhost").WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ” Credential helper in VM: exit=%d\n", helperCheck.ExitCode())

		// 	// Check config.json BEFORE login
		// 	dockerConfig := os.Getenv("DOCKER_CONFIG")
		// 	configPath := filepath.Join(dockerConfig, "config.json")
		// 	configContentBefore, readErr := os.ReadFile(configPath)
		// 	if readErr != nil {
		// 		fmt.Printf("ğŸ“„ config.json BEFORE login: file not found or error: %v\n", readErr)
		// 	} else {
		// 		fmt.Printf("ğŸ“„ config.json BEFORE login:\n%s\n", string(configContentBefore))
		// 	}

		// 	// Test credential workflow: login using same method as testFinchConfigFile
		// 	fmt.Printf("ğŸ” Attempting login to %s with user testUser...\n", registry)
		// 	fmt.Printf("ğŸ” Login debug: Running 'finch login %s -u testUser -p testPassword'\n", registry)
		// 	loginResult := command.New(o, "login", registry, "-u", "testUser", "-p", "testPassword").WithTimeoutInSeconds(30).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ” Login result: exit=%d, stdout=%s, stderr=%s\n", loginResult.ExitCode(), string(loginResult.Out.Contents()), string(loginResult.Err.Contents()))
		// 	gomega.Expect(loginResult.ExitCode()).To(gomega.Equal(0), "Login should succeed")
		// 	fmt.Printf("ğŸ” Login completed\n")

		// 	// Verify config.json has correct structure after login
		// 	configContent, readErr := os.ReadFile(configPath)
		// 	gomega.Expect(readErr).NotTo(gomega.HaveOccurred())
		// 	fmt.Printf("ğŸ“„ config.json AFTER login:\n%s\n", string(configContent))

		// 	// Test native credential helper directly on HOST
		// 	var nativeCredHelper string
		// 	if runtime.GOOS == "windows" {
		// 		nativeCredHelper = "docker-credential-wincred.exe"
		// 	} else {
		// 		nativeCredHelper = "docker-credential-osxkeychain"
		// 	}

		// 	// Check native credential helper path
		// 	nativeCredPath, pathErr := exec.LookPath(nativeCredHelper)
		// 	fmt.Printf("ğŸ’» Native credential helper path: %s (error: %v)\n", nativeCredPath, pathErr)

		// 	fmt.Printf("ğŸ’» Testing native credential helper on HOST: %s\n", nativeCredHelper)
		// 	hostCredCmd := exec.Command("sh", "-c", fmt.Sprintf("echo '%s' | %s get", registry, nativeCredHelper))
		// 	hostCredOutput, hostCredErr := hostCredCmd.CombinedOutput()
		// 	fmt.Printf("ğŸ’» Host native cred helper: error=%v, output=%s\n", hostCredErr, string(hostCredOutput))

		// 	// Verify config contains registry entry and credential store
		// 	gomega.Expect(string(configContent)).To(gomega.ContainSubstring(registry))
		// 	if runtime.GOOS == "windows" {
		// 		gomega.Expect(string(configContent)).To(gomega.ContainSubstring("wincred"))
		// 	} else {
		// 		gomega.Expect(string(configContent)).To(gomega.ContainSubstring("osxkeychain"))
		// 	}

		// 	// Test push/pull workflow
		// 	fmt.Printf("ğŸ“¦ Pulling hello-world image...\n")
		// 	pullResult := command.New(o, "pull", "hello-world").WithTimeoutInSeconds(60).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ“¦ Pull result: exit=%d, stdout=%s, stderr=%s\n", pullResult.ExitCode(), string(pullResult.Out.Contents()), string(pullResult.Err.Contents()))
		// 	gomega.Expect(pullResult.ExitCode()).To(gomega.Equal(0), "Pull should succeed")

		// 	fmt.Printf("ğŸ·ï¸ Tagging image as %s/hello:test...\n", registry)
		// 	tagResult := command.New(o, "tag", "hello-world", registry+"/hello:test").WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ·ï¸ Tag result: exit=%d, stdout=%s, stderr=%s\n", tagResult.ExitCode(), string(tagResult.Out.Contents()), string(tagResult.Err.Contents()))
		// 	gomega.Expect(tagResult.ExitCode()).To(gomega.Equal(0), "Tag should succeed")

		// 	// Debug push with verbose output
		// 	fmt.Printf("ğŸš€ Attempting push to %s/hello:test\n", registry)
		// 	pushResult := command.New(o, "push", registry+"/hello:test").WithTimeoutInSeconds(60).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ“¤ Push result: exit=%d, stdout=%s, stderr=%s\n", pushResult.ExitCode(), string(pushResult.Out.Contents()), string(pushResult.Err.Contents()))
		// 	gomega.Expect(pushResult.ExitCode()).To(gomega.Equal(0))

		// 	fmt.Printf("ğŸ§½ Cleaning up images...\n")
		// 	pruneResult := command.New(o, "system", "prune", "-f", "-a").WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ§½ Prune result: exit=%d, stdout=%s, stderr=%s\n", pruneResult.ExitCode(), string(pruneResult.Out.Contents()), string(pruneResult.Err.Contents()))

		// 	fmt.Printf("ğŸ“¦ Pulling test image from registry...\n")
		// 	pullTestResult := command.New(o, "pull", registry+"/hello:test").WithTimeoutInSeconds(60).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸ“¦ Pull test result: exit=%d, stdout=%s, stderr=%s\n", pullTestResult.ExitCode(), string(pullTestResult.Out.Contents()), string(pullTestResult.Err.Contents()))
		// 	gomega.Expect(pullTestResult.ExitCode()).To(gomega.Equal(0), "Pull from registry should succeed")

		// 	fmt.Printf("ğŸƒ Running test container...\n")
		// 	runResult := command.New(o, "run", "--rm", registry+"/hello:test").WithTimeoutInSeconds(30).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸƒ Run result: exit=%d, stdout=%s, stderr=%s\n", runResult.ExitCode(), string(runResult.Out.Contents()), string(runResult.Err.Contents()))
		// 	gomega.Expect(runResult.ExitCode()).To(gomega.Equal(0), "Run should succeed")

		// 	// Test logout
		// 	fmt.Printf("ğŸšª Logging out from registry...\n")
		// 	fmt.Printf("ğŸ” Logout debug: Running 'finch logout %s'\n", registry)
		// 	logoutResult := command.New(o, "logout", registry).WithoutCheckingExitCode().Run()
		// 	fmt.Printf("ğŸšª Logout result: exit=%d, stdout=%s, stderr=%s\n", logoutResult.ExitCode(), string(logoutResult.Out.Contents()), string(logoutResult.Err.Contents()))
		// 	gomega.Expect(logoutResult.ExitCode()).To(gomega.Equal(0), "Logout should succeed")

		// 	// Verify config.json no longer contains auth for this registry
		// 	configContentAfterLogout, readErr := os.ReadFile(configPath)
		// 	gomega.Expect(readErr).NotTo(gomega.HaveOccurred())
		// 	fmt.Printf("ğŸ“„ config.json after logout:\n%s\n", string(configContentAfterLogout))

		// 	// Should still have credsStore but no auth entry for the registry
		// 	gomega.Expect(string(configContentAfterLogout)).NotTo(gomega.ContainSubstring(registry))
		// })
	})
}
