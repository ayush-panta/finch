// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//go:build darwin || windows

package vm

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"

	"github.com/onsi/ginkgo/v2"
	"github.com/onsi/gomega"
	"github.com/runfinch/common-tests/command"
	"github.com/runfinch/common-tests/ffs"
	"github.com/runfinch/common-tests/fnet"
	"github.com/runfinch/common-tests/option"
)

// RegistryInfo contains registry connection details
type RegistryInfo struct {
	URL      string
	Username string
	Password string
}

// setupTestRegistry creates an authenticated local registry and returns connection info
func setupTestRegistry(o *option.Option) *RegistryInfo {
	filename := "htpasswd"
	registryImage := "public.ecr.aws/docker/library/registry:2"
	registryContainer := "auth-registry"
	// The htpasswd is generated by
	// `finch run --entrypoint htpasswd public.ecr.aws/docker/library/httpd:2 -Bbn testUser testPassword`.
	// We don't want to generate it on the fly because:
	// 1. Pulling the httpd image can take a long time, sometimes even more 10 seconds.
	// 2. It's unlikely that we will have to update this in the future.
	// 3. It's not the thing we want to validate by the functional tests. We only want the output produced by it.
	//nolint:gosec // This password is only used for testing purpose.
	htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
	htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
	ginkgo.DeferCleanup(os.RemoveAll, htpasswdDir)
	port := fnet.GetFreePort()
	containerID := command.StdoutStr(o, "run",
		"-dp", fmt.Sprintf("%d:5000", port),
		"--name", registryContainer,
		"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
		"-e", "REGISTRY_AUTH=htpasswd",
		"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
		"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
		registryImage)
	ginkgo.DeferCleanup(command.Run, o, "rmi", "-f", registryImage)
	ginkgo.DeferCleanup(command.Run, o, "rm", "-f", registryContainer)
	for command.StdoutStr(o, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
		time.Sleep(1 * time.Second)
	}
	time.Sleep(10 * time.Second)
	registry := fmt.Sprintf(`localhost:%d`, port)

	return &RegistryInfo{
		URL:      registry,
		Username: "testUser",
		Password: "testPassword",
	}
}

// cleanFinchConfig resets ~/.finch/config.json to clean state with only credential helper configured
func cleanFinchConfig() {
	var finchRootDir string
	var err error
	if runtime.GOOS == "windows" {
		finchRootDir = os.Getenv("LOCALAPPDATA")
	} else {
		finchRootDir, err = os.UserHomeDir()
		gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
	}

	finchDir := filepath.Join(finchRootDir, ".finch")
	err = os.MkdirAll(finchDir, 0755)
	gomega.Expect(err).ShouldNot(gomega.HaveOccurred())

	configPath := filepath.Join(finchDir, "config.json")
	var credStore string
	if runtime.GOOS == "windows" {
		credStore = "wincred"
	} else {
		credStore = "osxkeychain"
	}

	configContent := fmt.Sprintf(`{"credsStore": "%s"}`, credStore)
	err = os.WriteFile(configPath, []byte(configContent), 0644)
	gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
}

// testNativeCredHelper tests native credential helper functionality.
var testNativeCredHelper = func(o *option.Option, installed bool) {
	ginkgo.Describe("Native Credential Helper", func() {
		ginkgo.It("should have DOCKER_CONFIG set correctly", func() {
			// Verify DOCKER_CONFIG environment variable is set
			dockerConfig := os.Getenv("DOCKER_CONFIG")
			gomega.Expect(dockerConfig).ShouldNot(gomega.BeEmpty(), "DOCKER_CONFIG should be set")

			// Verify it points to the correct Finch directory
			var expectedFinchDir string
			if runtime.GOOS == "windows" {
				finchRootDir := os.Getenv("LOCALAPPDATA")
				expectedFinchDir = filepath.Join(finchRootDir, ".finch")
			} else {
				homeDir, err := os.UserHomeDir()
				gomega.Expect(err).ShouldNot(gomega.HaveOccurred())
				expectedFinchDir = filepath.Join(homeDir, ".finch")
			}

			gomega.Expect(dockerConfig).Should(gomega.Equal(expectedFinchDir), "DOCKER_CONFIG should point to ~/.finch")
			fmt.Printf("‚úì DOCKER_CONFIG is correctly set to: %s\n", dockerConfig)
		})

		ginkgo.It("should have finchhost credential helper in VM PATH", func() {
			resetVM(o)
			resetDisks(o, installed)
			command.New(o, virtualMachineRootCmd, "init").WithTimeoutInSeconds(160).Run()

			limaOpt, err := limaCtlOpt(installed)
			gomega.Expect(err).NotTo(gomega.HaveOccurred())

			result := command.New(limaOpt, "shell", "finch", "command", "-v", "docker-credential-finchhost").WithoutCheckingExitCode().Run()
			fmt.Printf("docker-credential-finchhost path: %s\n", string(result.Out.Contents()))
			gomega.Expect(result.ExitCode()).To(gomega.Equal(0), "docker-credential-finchhost should be in VM PATH")
		})

		ginkgo.It("should have native credential helper available on host", func() {
			var credHelper string
			if runtime.GOOS == "windows" {
				credHelper = "docker-credential-wincred"
			} else {
				credHelper = "docker-credential-osxkeychain"
			}

			// Check if native credential helper is available on the HOST system
			_, err := exec.LookPath(credHelper)
			gomega.Expect(err).NotTo(gomega.HaveOccurred(), "Native credential helper %s should be available on host", credHelper)
		})

		ginkgo.It("should work with registry push/pull workflow", func() {
			// Clean config and setup fresh environment
			cleanFinchConfig()
			resetVM(o)
			resetDisks(o, installed)
			command.New(o, virtualMachineRootCmd, "init").WithTimeoutInSeconds(160).Run()

			// Setup test registry - EXACTLY like testFinchConfigFile
			filename := "htpasswd"
			registryImage := "public.ecr.aws/docker/library/registry:2"
			registryContainer := "auth-registry"
			//nolint:gosec // This password is only used for testing purpose.
			htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
			htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
			ginkgo.DeferCleanup(os.RemoveAll, htpasswdDir)
			port := fnet.GetFreePort()
			containerID := command.StdoutStr(o, "run",
				"-dp", fmt.Sprintf("%d:5000", port),
				"--name", registryContainer,
				"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
				"-e", "REGISTRY_AUTH=htpasswd",
				"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
				"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
				registryImage)
			ginkgo.DeferCleanup(command.Run, o, "rmi", "-f", registryImage)
			ginkgo.DeferCleanup(command.Run, o, "rm", "-f", registryContainer)
			for command.StdoutStr(o, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
				time.Sleep(1 * time.Second)
			}
			time.Sleep(10 * time.Second)
			
			// Wait for registry to actually accept HTTP requests
			registry := fmt.Sprintf(`localhost:%d`, port)
			fmt.Printf("üîß Registry container running, waiting for HTTP service at %s...\n", registry)
			for i := 0; i < 30; i++ {
				// Try to connect to registry API endpoint using busybox (smaller image)
				testResult := command.New(o, "run", "--rm", "public.ecr.aws/docker/library/busybox:latest", 
					"sh", "-c", fmt.Sprintf("wget -q -O - http://%s/v2/ >/dev/null 2>&1", registry)).WithoutCheckingExitCode().Run()
				if testResult.ExitCode() == 0 {
					fmt.Printf("‚úÖ Registry HTTP service ready after %d seconds\n", i+1)
					break
				}
				if i == 29 {
					fmt.Printf("‚ùå Registry HTTP service not ready after 30 seconds\n")
					ginkgo.Fail("Registry failed to become ready")
				}
				time.Sleep(1 * time.Second)
			}
			
			// Additional wait for registry to be fully stable
			time.Sleep(5 * time.Second)
			fmt.Printf("üîß Registry setup complete: %s (user: testUser)\n", registry)

			// Verify credential helper is available in VM
			limaOpt, err := limaCtlOpt(installed)
			gomega.Expect(err).NotTo(gomega.HaveOccurred())
			helperCheck := command.New(limaOpt, "shell", "finch", "command", "-v", "docker-credential-finchhost").WithoutCheckingExitCode().Run()
			fmt.Printf("üîç Credential helper in VM: exit=%d\n", helperCheck.ExitCode())

			// Check config.json BEFORE login
			dockerConfig := os.Getenv("DOCKER_CONFIG")
			configPath := filepath.Join(dockerConfig, "config.json")
			configContentBefore, readErr := os.ReadFile(configPath)
			if readErr != nil {
				fmt.Printf("üìÑ config.json BEFORE login: file not found or error: %v\n", readErr)
			} else {
				fmt.Printf("üìÑ config.json BEFORE login:\n%s\n", string(configContentBefore))
			}

			// Test credential workflow: login using same method as testFinchConfigFile
			command.Run(o, "login", registry, "-u", "testUser", "-p", "testPassword")
			fmt.Printf("üîê Login completed\n")

			// Verify config.json has correct structure after login
			configContent, readErr := os.ReadFile(configPath)
			gomega.Expect(readErr).NotTo(gomega.HaveOccurred())
			fmt.Printf("üìÑ config.json AFTER login:\n%s\n", string(configContent))

			// Test native credential helper directly on HOST
			var nativeCredHelper string
			if runtime.GOOS == "windows" {
				nativeCredHelper = "docker-credential-wincred.exe"
			} else {
				nativeCredHelper = "docker-credential-osxkeychain"
			}
			
			// Check native credential helper path
			nativeCredPath, pathErr := exec.LookPath(nativeCredHelper)
			fmt.Printf("üíª Native credential helper path: %s (error: %v)\n", nativeCredPath, pathErr)
			
			fmt.Printf("üíª Testing native credential helper on HOST: %s\n", nativeCredHelper)
			hostCredCmd := exec.Command("sh", "-c", fmt.Sprintf("echo '%s' | %s get", registry, nativeCredHelper))
			hostCredOutput, hostCredErr := hostCredCmd.CombinedOutput()
			fmt.Printf("üíª Host native cred helper: error=%v, output=%s\n", hostCredErr, string(hostCredOutput))

			// Verify config contains registry entry and credential store
			gomega.Expect(string(configContent)).To(gomega.ContainSubstring(registry))
			if runtime.GOOS == "windows" {
				gomega.Expect(string(configContent)).To(gomega.ContainSubstring("wincred"))
			} else {
				gomega.Expect(string(configContent)).To(gomega.ContainSubstring("osxkeychain"))
			}

			// Test push/pull workflow
			command.New(o, "pull", "hello-world").WithTimeoutInSeconds(60).Run()
			command.New(o, "tag", "hello-world", registry+"/hello:test").Run()

			// Debug push with verbose output
			fmt.Printf("üöÄ Attempting push to %s/hello:test\n", registry)
			pushResult := command.New(o, "push", registry+"/hello:test").WithTimeoutInSeconds(60).WithoutCheckingExitCode().Run()
			fmt.Printf("üì§ Push result: exit=%d, stdout=%s, stderr=%s\n", pushResult.ExitCode(), string(pushResult.Out.Contents()), string(pushResult.Err.Contents()))
			gomega.Expect(pushResult.ExitCode()).To(gomega.Equal(0))

			command.New(o, "system", "prune", "-f", "-a").Run()
			command.New(o, "pull", registry+"/hello:test").WithTimeoutInSeconds(60).Run()
			command.New(o, "run", "--rm", registry+"/hello:test").WithTimeoutInSeconds(30).Run()

			// Test logout
			command.Run(o, "logout", registry)

			// Verify config.json no longer contains auth for this registry
			configContentAfterLogout, readErr := os.ReadFile(configPath)
			gomega.Expect(readErr).NotTo(gomega.HaveOccurred())
			fmt.Printf("üìÑ config.json after logout:\n%s\n", string(configContentAfterLogout))

			// Should still have credsStore but no auth entry for the registry
			gomega.Expect(string(configContentAfterLogout)).NotTo(gomega.ContainSubstring(registry))
		})
	})
}
